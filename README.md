# Оптимизация функции (UDF) возврата списка заказов
Задание к курсу Оптимизация БД

## Порядок выполнения и взаимодействия
1. Все вопросы оформлять в виде Issue
2. Все изменения и результаты оформлять в виде Pull Request из собственного fork

## Описание
В репозитории находится скрипт для создания объектов БД (MS SQL Server).
Описание таблиц:
* `Works` - заказы на проведение исследований
* `WorkItem` - элементы заказа (заказанное исследование)
* `Analiz` - спецификации исследования
* `Employee` - сотрудники
Остальные таблицы для выполнения задания значения не имеют.

Для получения списка заказов с заранее настроенным количеством, со стороны клиентского приложения направляется запрос:

`select top 3000 * from dbo.F_WORKS_LIST()`

## Требования к окружению
MS SQL Server любой версии (допустимо использовать MS SQL Server for Linux или Windows).
Допустимо использование иной СУБД при портировании исходного скрипта с учётом конечного диалекта SQL.
## Начальные действия
1. Ознакомиться со скриптом создания базы данных
2. Ознакомиться с программными компонентами (функции)
3. Разработать и применить генератор тестовых данных

Ожидаемый результат - доступная для оптимизации БД с тестовыми данными

## Проблема
Пользователи приложения пользуются на низкую производительность при загрузке списка, при этом отсутствуют возможности отладить приложение и внести в него правки.

## Задача 1-го уровня
Проанализировать скрипт функции получения списка заказов и связанные с ней объекты, перечислить выявленные недочёты и потенциальные проблемы производительности.

- `ORDER BY id_work DESC` в функции не влияет на порядок, а значит её можно убрать.
- Используется `RETURN @RESULT`, а это мешает автоматической оптимизации.
- `dbo.F_EMPLOYEE_FULLNAME` вызывается очень много раз. Если у нас 1 работник сделал миллион заказов, то мы конструируем ФИО миллион раз :)
- Непонятная проверка `WHERE Works.Is_Del <> 1`, поле `Is_Del` всё равно принимает только 2 значения.
- `F_WORKITEMS_COUNT_BY_ID_WORK` вызывается дважды.

## Задача 2-го уровня
Предложить правки запросов без модификации структуры БД такие, что время выполнения запроса получения `3 000` заказов из `50 000` со средним количеством элементов в заказе равным `3` не будет превышать `1-2` сек.
При выполнении задания допускается использовать LLM. В случае использования LLM должны быть приведены используемые промты на русском или английском языке.

- Удалена сортировака: `ORDER BY id_work DESC`
- `F_WORKS_LIST` переписана как inline TVF для улучшенной производительности.
- `F_EMPLOYEE_FULLNAME` реализована как JOIN.
- `WHERE Works.Is_Del <> 1` - > `WHERE Works.Is_Del = 0`
- `F_WORKITEMS_COUNT_BY_ID_WORK` -> LEFT JOIN and GROUP BY

## Задача 3-го уровня
Если для оптимизации требуется создание новых таблиц, столбцов, триггеров или хранимых процедур (функций), то необходимо описать возможные недостатки и отрицательные последствия от таких изменений.

Недостатки iTVF:
  - Нет кэширования: результат вычисляется каждый раз при вызове.
  - Ограниченная оптимизация: хотя план встраивается, сложные подзапросы внутри могут мешать оптимизатору.
  - Зависимость от вызывающего запроса: производительность сильно зависит от того, как и где вызывается функция.
  - Может дублировать логику: сложно отлаживать и повторно использовать, если она повторяет сложный SQL.
 
Недостатки индексов:
  - Занимают место: каждый индекс — это дополнительное хранилище.
  - Замедляют INSERT/UPDATE/DELETE: нужно поддерживать индекс в актуальном состоянии.
  - Риск избыточности: множество неиспользуемых или дублирующих индексов ухудшает общую производительность.
  - Не всегда используются: если запрос написан неоптимально или структура таблицы изменилась, индекс может игнорироваться.
